
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module FSM_MEALY(

/*	//////////// CLOCK //////////
	input 		          		CLOCK_50,
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
*/
	//////////// LED //////////
//	output		     [8:0]		LEDG,
//	output		    [17:0]		LEDR,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		    [17:0]		SW,

	//////////// SEG7 //////////
	output	reg	     [6:0]		HEX0,
	output	reg	     [6:0]		HEX1,
	output	reg	     [6:0]		HEX2,
	output	reg	     [6:0]		HEX3,
	output	reg	     [6:0]		HEX4,
	output	reg	     [6:0]		HEX5,
	output	reg	     [6:0]		HEX6,
	output	reg	     [6:0]		HEX7,
	
	
	
	
	output reg success_output, 
	output reg [5:0] count_z,   
	output reg [2:0] current_state,next_state
	
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

parameter start    = 3'b000,
          first    = 3'b001,
          second   = 3'b011,
          third    = 3'b010,
          delay    = 3'b110,
          successD = 3'b111,
          success  = 3'b101;

integer count_value_number = 0;
integer count_value_max = 99;
integer sequential_inputD = 0;

integer count_digit0 = 0;
integer count_digit1 = 0;


// Check KEY[0], hold at start, or move to next state

  always @(posedge KEY[1]) 
    begin 
      if(!KEY[0])   
        current_state <= start; 
      else         
        current_state <= next_state; 
    end  

    



always @(*)
  begin
    if(SW[0])
      sequential_inputD <= 1'b1;
    else if(!SW[0])
      sequential_inputD <= 1'b0;
  end



  always @(*) 
    begin

      if (!KEY[0]) //If KEY[0] is equal to 0, program returns to start
        next_state = start; 

    else  
    
  	 success_output <= (current_state == successD) | (current_state == success);
    begin 
      case(current_state) 
      
      start: begin 
             
              if (sequential_inputD==1)
                next_state = start;     
              else                      
                next_state = first;           
             end  
               
      first: begin 
             
              if (sequential_inputD==1)
                next_state = second;     
              else                      
                next_state = first;               
             end 
      
      second: begin

              if (sequential_inputD==1)                              
                next_state = third;
              else                 
                next_state = first;                     
             end 
      
      third: begin

              if (sequential_inputD==1)                              
                next_state = success;
              else                 
                next_state = delay;                     
             end 

      delay: begin 
             
              if (sequential_inputD==1)               
                next_state = successD; 
              else                  
                next_state = delay;           
             end 
      
      successD: begin 
             
              if (sequential_inputD==1)               
                next_state = third; 
              else                  
                next_state = first;           
             end              

      success: begin 
             
              if (sequential_inputD==1)               
                next_state = start; 
              else                     
                next_state = first;           
             end 

      default: begin 
                next_state = start; 
               end 
      
      endcase 
    
    end
   end 




   
  // COUNT count_z, z
  always @(posedge KEY[1]) 
    begin 

      if(!KEY[0]) begin            
        count_value_number <= 0; 
      end
	if(count_value_number==count_value_max)
		count_value_number<=0;

      else if (current_state == successD | current_state == success) 
        count_value_number <= count_value_number + 1; 
		count_z <= count_value_number;
		
    
    end





  always @(*) 
    begin 
      if(KEY[0] == 1'b0)          
             HEX7 = 7'b0111111; 
      else                       
        begin 
          case(success_output) 
            0: HEX7 = 7'b1000000; 
            1: HEX7 = 7'b1111001; 
            default: HEX7 = 7'b0111111; 
            endcase
          end
        end







  always @(*) 
    begin 
      if(!KEY[0]) begin    
 		  HEX0 = 7'b0111111; 
	     HEX1 = 7'b0111111;		 
	     HEX2 = 7'b0111111;       
		  
		  HEX4 = 7'b0111111; 
	     HEX5 = 7'b0111111;
	end

      else                       
        begin 
		  HEX6 = 7'b1111111;
		  HEX3 = 7'b1111111;
	

		  
		case(current_state) 
		 3'b000: HEX0 = 7'b1000000; //0 
	    3'b001: HEX0 = 7'b1111001;
		 3'b011: HEX0 = 7'b1111001;
		 3'b010: HEX0 = 7'b1000000;
		 3'b110: HEX0 = 7'b1000000;
		 3'b111: HEX0 = 7'b1111001;
		 3'b101: HEX0 = 7'b1111001;
		 endcase
		 
		 case(current_state) 
		 3'b000: HEX1 = 7'b1000000; 
	    3'b001: HEX1 = 7'b1000000;
		 3'b011: HEX1 = 7'b1111001;
		 3'b010: HEX1 = 7'b1111001;
		 3'b110: HEX1 = 7'b1111001;
		 3'b111: HEX1 = 7'b1111001;
		 3'b101: HEX1 = 7'b1000000; 
		 endcase
		 
		 case(current_state) 
		 3'b000: HEX2 = 7'b1000000; 
	    3'b001: HEX2 = 7'b1000000;
		 3'b011: HEX2 = 7'b1000000;
		 3'b010: HEX2 = 7'b1000000;
		 3'b110: HEX2 = 7'b1111001;
		 3'b111: HEX2 = 7'b1111001;
		 3'b101: HEX2 = 7'b1111001; 
		 endcase
		  
		  
		  
		  
		  
	count_digit0 <= count_value_number%10;
	
          case(count_digit0) 
            0: HEX4 = 7'b1000000; 
            1: HEX4 = 7'b1111001; 
            2: HEX4 = 7'b0100100; 
            3: HEX4 = 7'b0110000; 
            4: HEX4 = 7'b0011001; 
            5: HEX4 = 7'b0010010; 
            6: HEX4 = 7'b0000010; 
            7: HEX4 = 7'b1111000; 
            8: HEX4 = 7'b0000000; 
            9: HEX4 = 7'b0011000; 
            default: HEX4 = 7'b0111111;
		endcase
	

	count_digit1 <= count_value_number/10; 
          case(count_digit1) 
            0: HEX5 = 7'b1000000; 
            1: HEX5 = 7'b1111001; 
            2: HEX5 = 7'b0100100; 
            3: HEX5 = 7'b0110000; 
            4: HEX5 = 7'b0011001; 
            5: HEX5 = 7'b0010010; 
            6: HEX5 = 7'b0000010; 
            7: HEX5 = 7'b1111000; 
            8: HEX5 = 7'b0000000; 
            9: HEX5 = 7'b0011000; 
            default: HEX5 = 7'b0111111;


          endcase 
        end
    end 





endmodule 



//=======================================================
//  Structural coding
//=======================================================




