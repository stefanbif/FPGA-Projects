//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module FSM_MEALY(

/*	//////////// CLOCK //////////
	input 		          		CLOCK_50,
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
*/
	//////////// LED //////////
//	output		     [8:0]		LEDG,
//	output		    [17:0]		LEDR,

	//////////// KEY //////////
	input 		     [3:0]		KEY, //KEY[0] Reset, KEY[1] Clock

	//////////// SW //////////
	input 		    [17:0]		SW,  //SW[0] --> sequential_inputD

	//////////// SEG7 //////////
	output	reg	     [6:0]		HEX0,	//next_state[0]	
	output	reg	     [6:0]		HEX1,	//next_state[1]
	output	reg	     [6:0]		HEX2,	//next_state[2]	
	output	reg	     [6:0]		HEX3,
	output	reg	     [6:0]		HEX4,	//count_z[1]
	output	reg	     [6:0]		HEX5,	//count_z[2]
	output	reg	     [6:0]		HEX6,
	output	reg	     [6:0]		HEX7,	//success_output
	
	
	
	
	output reg success_output,	//Used to display if the sequence has reached sucsess
	output reg [5:0] count_z,   //Used to count and display the numb er of times succsess has been reached
	output reg [2:0] current_state,next_state //Used to store the value of the current and next state 
	
);

//=======================================================
//  REG/WIRE declarations
//=======================================================
//Declaring each state as a constant
parameter start    = 3'b000,
          first    = 3'b001,
          second   = 3'b011,
          third    = 3'b010,
          delay    = 3'b110,
          successD = 3'b111,
          success  = 3'b101;
//Declaring all variables 
integer count_value_number = 0; //Initialize to 0 
integer count_value_max = 99;	//Initialize max counter value to 99
integer sequential_inputD = 0;	//Initialize input to 0 
integer count_digit0 = 0;		//Initialize the 0th digit of the counter to 0
integer count_digit1 = 0;		//Initialize the 10's digit of the counter to 0


  always @(posedge KEY[1]) // Check KEY[0], hold at start, or move to next state
    begin 
      if(!KEY[0])   
        current_state <= start; //If KEY[0] is pressed, reset and return to start
      else         
        current_state <= next_state; //If KEY[0] is not pressed, proceed to next state
    end  

   
   
//Used to determine input from SW[0] upon clock pulse
always @(*)
  begin
    if(SW[0]) //If switch is on, input will be 1
      sequential_inputD <= 1'b1;
    else if(!SW[0]) //If switch is off, input will be 0
      sequential_inputD <= 1'b0;
  end


//Always block for case statments
  always @(*) 
    begin

      if (!KEY[0]) //If KEY[0] is pressed, program returns to start
        next_state = start; 

    else  //success_output when it is equal to success or successD
    
  	 success_output <= (current_state == successD) | (current_state == success);
    begin 
      case(current_state) 
      
      start: begin //000, if input is 1, stay at start, if input is 0, go to first
             
              if (sequential_inputD==1)
                next_state = start;     
              else                      
                next_state = first;           
             end  
               
      first: begin //001, if input is 1, go to second, if input is 0, stay at first 
             
              if (sequential_inputD==1)
                next_state = second;     
              else                      
                next_state = first;               
             end 
      
      second: begin //011 if input is 1, go to third, if inpujt is 0, go to first 

              if (sequential_inputD==1)                              
                next_state = third;
              else                 
                next_state = first;                     
             end 
      
      third: begin //010 if input is 1, go to success, if input is 0, go to delay

              if (sequential_inputD==1)                              
                next_state = success;
              else                 
                next_state = delay;                     
             end 

      delay: begin //011 if input is 1, go to successD, if input is 0, stay at delay
             
              if (sequential_inputD==1)               
                next_state = successD; 
              else                  
                next_state = delay;           
             end 
      
      successD: begin // 111 if input is 1, go to third, if input is 0, go to first 
             
              if (sequential_inputD==1)               
                next_state = third; 
              else                  
                next_state = first;           
             end              

      success: begin //101 if input is 1, go to start, if input is 0, go to first
             
              if (sequential_inputD==1)               
                next_state = start; 
              else                     
                next_state = first;           
             end 

      default: begin //program will begin at start
                next_state = start; 
               end 
      
      endcase 
    
    end
   end 




   
  // Block for the counter count_z
  always @(posedge KEY[1]) //At the positive edge of the clock
    begin 

      if(!KEY[0]) begin            //If the button KEY[0] is pressed, the value of the counter will be reset to 0
        count_value_number <= 0; 
      end
	if(count_value_number==count_value_max)	//If the counter reaches 99, the max value that can be displayed on a 2 digit display, reset o 0
		count_value_number<=0;

      else if (current_state == successD | current_state == success) //If the state equals either success or successD, increment the counter by 1
        count_value_number <= count_value_number + 1; 
		count_z <= count_value_number;
		
    
    end




	//Display the value of success_output, 0 or 1 if success or successD has been reached on the 7-segment display 
  always @(*) 
    begin 
      if(KEY[0] == 1'b0)         // if the reset button is pushed, while pushed update the dispays to only show the center line
             HEX7 = 7'b0111111; 
      else                       
        begin 
          case(success_output) 
            0: HEX7 = 7'b1000000; 
            1: HEX7 = 7'b1111001; 
            default: HEX7 = 7'b0111111; 
            endcase
          end
        end






	//if the reset button is pushed, while pushed update the dispays to only show the center line 
  always @(*) 
    begin 
      if(!KEY[0]) begin    
 		  HEX0 = 7'b0111111; 
	     HEX1 = 7'b0111111;		 
	     HEX2 = 7'b0111111;       
		  
		  HEX4 = 7'b0111111; 
	     HEX5 = 7'b0111111;
	end

      else		//set the displays on the board not being used to be off 
        begin 
		  HEX6 = 7'b1111111;
		  HEX3 = 7'b1111111;
	
		//Display the values of current_state on HEX[0] (first bit), HEX[1] (second bit) and HEX[2] (third bit)
		  
		case(current_state) 
		 3'b000: HEX0 = 7'b1000000; //000
	     3'b001: HEX0 = 7'b1111001; //001
		 3'b011: HEX0 = 7'b1111001; //011
		 3'b010: HEX0 = 7'b1000000;	//010
		 3'b110: HEX0 = 7'b1000000;	//110
		 3'b111: HEX0 = 7'b1111001; //111
		 3'b101: HEX0 = 7'b1111001; //101
		 endcase
		 
		 case(current_state) 
		 3'b000: HEX1 = 7'b1000000; 
	     3'b001: HEX1 = 7'b1000000;
		 3'b011: HEX1 = 7'b1111001;
		 3'b010: HEX1 = 7'b1111001;
		 3'b110: HEX1 = 7'b1111001;
		 3'b111: HEX1 = 7'b1111001;
		 3'b101: HEX1 = 7'b1000000; 
		 endcase
		 
		 case(current_state) 
		 3'b000: HEX2 = 7'b1000000; 
	     3'b001: HEX2 = 7'b1000000;
		 3'b011: HEX2 = 7'b1000000;
		 3'b010: HEX2 = 7'b1000000;
		 3'b110: HEX2 = 7'b1111001;
		 3'b111: HEX2 = 7'b1111001;
		 3'b101: HEX2 = 7'b1111001; 
		 endcase
		  
		  
		  
	//Display the values of the counter, count_z on HEX[4]and HEX[5]	  
		  
	count_digit0 <= count_value_number%10;
	
          case(count_digit0) 
            0: HEX4 = 7'b1000000; 
            1: HEX4 = 7'b1111001; 
            2: HEX4 = 7'b0100100; 
            3: HEX4 = 7'b0110000; 
            4: HEX4 = 7'b0011001; 
            5: HEX4 = 7'b0010010; 
            6: HEX4 = 7'b0000010; 
            7: HEX4 = 7'b1111000; 
            8: HEX4 = 7'b0000000; 
            9: HEX4 = 7'b0011000; 
            default: HEX4 = 7'b0111111;
		endcase
	

	count_digit1 <= count_value_number/10; 
          case(count_digit1) 
            0: HEX5 = 7'b1000000; 
            1: HEX5 = 7'b1111001; 
            2: HEX5 = 7'b0100100; 
            3: HEX5 = 7'b0110000; 
            4: HEX5 = 7'b0011001; 
            5: HEX5 = 7'b0010010; 
            6: HEX5 = 7'b0000010; 
            7: HEX5 = 7'b1111000; 
            8: HEX5 = 7'b0000000; 
            9: HEX5 = 7'b0011000; 
            default: HEX5 = 7'b0111111;


          endcase 
        end
    end 





endmodule 
